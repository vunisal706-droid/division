<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="apple-mobile-web-app-title" content="Divisi√≥n Quest">
    <meta name="theme-color" content="#D4A574">
    <meta name="description" content="Juego educativo de divisiones para 4¬∫-6¬∫ de primaria">
    <title>Divisi√≥n Quest - Aventura Egipcia</title>
    <link rel="manifest" href="manifest_division.json">
    <link href="https://fonts.googleapis.com/css2?family=Andika:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #D4A574 0%, #8B6914 100%);
            font-family: 'Andika', 'Comic Sans MS', cursive;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            touch-action: none;
            margin: 0;
            padding: 0;
        }
        #gameCanvas {
            border-radius: 8px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1000" height="700"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Sistema de audio
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq1, freq2, duration) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq1, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(freq2, audioContext.currentTime + duration * 0.5);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Datos del juego
        const gameData = {
            coins: 0,
            lives: 3,
            currentLevel: 1,
            unlockedLevels: 1,
            currentExplorer: 'classic',
            ownedExplorers: ['classic'],
            divisionsCorrect: 0,
            scene: 'menu'
        };

        // Divisiones por nivel
        const levelDivisions = {
            1: [[10,2],[12,3],[15,3],[20,4],[16,4],[18,3],[21,7],[24,6],[27,9],[30,5]],
            2: [[24,4],[32,8],[36,6],[40,5],[45,9],[48,6],[54,9],[56,7],[63,9],[72,8]],
            3: [[42,6],[49,7],[56,8],[64,8],[81,9],[35,7],[28,4],[48,8],[63,7],[36,4]],
            4: [[84,7],[96,8],[72,6],[60,5],[88,8],[77,7],[90,9],[66,6],[55,5],[99,9]],
            5: [[144,12],[156,13],[132,11],[168,14],[180,15],[120,10],[165,15],[143,11],[169,13],[192,16]],
            6: [[225,15],[240,16],[210,14],[270,18],[300,20],[195,13],[264,12],[288,16],[336,21],[252,14]],
            7: [[25,4],[30,7],[45,8],[50,6],[37,5],[41,6],[53,7],[62,8],[71,9],[83,10]],
            8: [[95,12],[110,13],[125,14],[140,15],[156,17],[173,18],[189,19],[205,20],[221,21],[237,22]],
            9: [[300,23],[350,24],[400,27],[450,31],[500,33],[550,37],[600,41],[650,43],[700,47],[750,49]]
        };

        // Divisiones EXACTAS para el cofre del tesoro (una por nivel)
        const chestDivisions = {
            1: [48, 4],     // = 12
            2: [100, 5],    // = 20
            3: [150, 6],    // = 25
            4: [210, 7],    // = 30
            5: [256, 8],    // = 32
            6: [288, 9],    // = 32
            7: [350, 10],   // = 35
            8: [440, 11],   // = 40
            9: [480, 12]    // = 40
        };

        // Exploradores
        const explorers = [
            { name: 'Cl√°sico', id: 'classic', price: 0 },
            { name: 'Indiana', id: 'indiana', price: 8 },
            { name: 'Arque√≥loga', id: 'archaeologist', price: 8 },
            { name: 'Aventurero', id: 'adventurer', price: 8 },
            { name: 'Fara√≥n', id: 'pharaoh', price: 10 },
            { name: 'Cleopatra', id: 'cleopatra', price: 10 },
            { name: 'Anubis', id: 'anubis', price: 12 }
        ];

        // Player
        const player = {
            x: 100, y: 500,
            width: 60, height: 75,
            velocityX: 0, velocityY: 0,
            speed: 6, jumpPower: 16, gravity: 0.6,
            onGround: false, invincible: false, invincibleTimer: 0
        };

        const PLAYER_SCALE = 1.5;

        // Game state
        let currentDivisions = [];
        let temples = [];
        let scorpions = [];
        let traps = [];
        let mummy = null;
        let treasureChest = null;
        let cameraX = 0;
        let showingKeypad = false;
        let currentTemple = null;
        let playerAnswer = '';
        let gameTime = 0;

        // Input
        const keys = {};
        let touchLeft = false;
        let touchRight = false;
        let touchJump = false;
        let activeTouches = {};

        // Zonas de controles
        const controlZones = {
            left: { cx: 100, cy: 620, r: 55 },
            jump: { cx: 220, cy: 620, r: 55 },
            right: { cx: 340, cy: 620, r: 55 }
        };

        // ============ EVENTOS DE INPUT ============
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (showingKeypad && /^[0-9]$/.test(e.key)) {
                if (playerAnswer.length < 5) playerAnswer += e.key;
            }
            if (showingKeypad && e.key === 'Backspace') {
                playerAnswer = playerAnswer.slice(0, -1);
            }
            if (showingKeypad && e.key === 'Enter') {
                submitAnswer();
            }
        });

        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Funci√≥n para obtener coordenadas del canvas
        function getCanvasCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        // MOUSE
        canvas.addEventListener('mousedown', (e) => {
            const coords = getCanvasCoords(e.clientX, e.clientY);
            handleInteraction(coords.x, coords.y, 'mouse');
        });

        canvas.addEventListener('mouseup', () => {
            delete activeTouches['mouse'];
            updateTouchControls();
        });

        canvas.addEventListener('mouseleave', () => {
            delete activeTouches['mouse'];
            updateTouchControls();
        });

        // TOUCH
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const coords = getCanvasCoords(touch.clientX, touch.clientY);
                handleInteraction(coords.x, coords.y, touch.identifier);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const coords = getCanvasCoords(touch.clientX, touch.clientY);
                if (activeTouches[touch.identifier] && gameData.scene === 'game' && !showingKeypad) {
                    activeTouches[touch.identifier].x = coords.x;
                    activeTouches[touch.identifier].y = coords.y;
                    checkControlZone(coords.x, coords.y, touch.identifier);
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                delete activeTouches[touch.identifier];
            }
            updateTouchControls();
        });

        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                delete activeTouches[touch.identifier];
            }
            updateTouchControls();
        });

        function handleInteraction(x, y, touchId) {
            // Si estamos en el keypad, solo manejar clicks en botones
            if (showingKeypad) {
                handleKeypadClick(x, y);
                return;
            }

            // Si estamos en el juego, verificar controles
            if (gameData.scene === 'game') {
                activeTouches[touchId] = { x, y, control: null, jumpUsed: false };
                checkControlZone(x, y, touchId);
            }

            // Manejar clicks en botones de UI
            handleClick(x, y);
        }

        function checkControlZone(x, y, touchId) {
            if (showingKeypad) return;
            
            let control = null;
            if (dist(x, y, controlZones.left.cx, controlZones.left.cy) < controlZones.left.r) {
                control = 'left';
            } else if (dist(x, y, controlZones.jump.cx, controlZones.jump.cy) < controlZones.jump.r) {
                control = 'jump';
            } else if (dist(x, y, controlZones.right.cx, controlZones.right.cy) < controlZones.right.r) {
                control = 'right';
            }

            if (activeTouches[touchId]) {
                activeTouches[touchId].control = control;
            }
            updateTouchControls();
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
        }

        function updateTouchControls() {
            touchLeft = false;
            touchRight = false;

            for (let id in activeTouches) {
                const touch = activeTouches[id];
                if (touch.control === 'left') touchLeft = true;
                if (touch.control === 'right') touchRight = true;
                if (touch.control === 'jump' && !touch.jumpUsed) {
                    touchJump = true;
                    touch.jumpUsed = true;
                    setTimeout(() => touchJump = false, 100);
                }
            }
        }

        // ============ FUNCIONES DE DIBUJO ============
        function drawRect(x, y, w, h, color, stroke = null, radius = 0) {
            ctx.fillStyle = color;
            if (radius > 0) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                ctx.fill();
                if (stroke) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            } else {
                ctx.fillRect(x, y, w, h);
                if (stroke) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);
                }
            }
        }

        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawText(text, x, y, size, color, align = 'left', stroke = false) {
            ctx.font = `bold ${size}px Andika, Arial, sans-serif`;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.textBaseline = 'middle';
            if (stroke) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.strokeText(text, x, y);
            }
            ctx.fillText(text, x, y);
        }

        function drawButton(x, y, w, h, text, color, textSize = 20) {
            // Sombra
            drawRect(x + 3, y + 3, w, h, 'rgba(0,0,0,0.4)', null, 10);
            // Bot√≥n
            drawRect(x, y, w, h, color, '#fff', 10);
            drawText(text, x + w/2, y + h/2, textSize, '#fff', 'center');
            return { x, y, w, h };
        }

        // ============ DIBUJAR PIR√ÅMIDE ============
        function drawPyramid(x, y, solved) {
            const baseWidth = 120, height = 100;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x - baseWidth/2 + 5, y + 5);
            ctx.lineTo(x + baseWidth/2 + 5, y + 5);
            ctx.lineTo(x + 5, y - height + 5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = solved ? '#90EE90' : '#D2B48C';
            ctx.beginPath();
            ctx.moveTo(x - baseWidth/2, y);
            ctx.lineTo(x + baseWidth/2, y);
            ctx.lineTo(x, y - height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = solved ? '#7CCD7C' : '#C9A876';
            ctx.beginPath();
            ctx.moveTo(x - baseWidth/2, y);
            ctx.lineTo(x, y - height);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = solved ? '#98FB98' : '#DEB887';
            ctx.beginPath();
            ctx.moveTo(x + baseWidth/2, y);
            ctx.lineTo(x, y - height);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - baseWidth/2, y);
            ctx.lineTo(x + baseWidth/2, y);
            ctx.lineTo(x, y - height);
            ctx.closePath();
            ctx.stroke();

            if (!solved) {
                ctx.strokeStyle = '#A0826D';
                ctx.lineWidth = 2;
                for (let i = 1; i < 5; i++) {
                    const yPos = y - (height / 5) * i;
                    const widthAtLevel = baseWidth * (1 - i / 5);
                    ctx.beginPath();
                    ctx.moveTo(x - widthAtLevel/2, yPos);
                    ctx.lineTo(x + widthAtLevel/2, yPos);
                    ctx.stroke();
                }
                drawEgyptianSymbol(x, y - height/2);
            } else {
                ctx.fillStyle = '#2E7D32';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚úì', x, y - height/2);
            }
        }

        function drawEgyptianSymbol(x, y) {
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(x, y, 18, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x, y - 18, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(x, y, 18, 22, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawScorpion(x, y) {
            ctx.fillStyle = '#4A2511';
            ctx.beginPath();
            ctx.ellipse(x, y, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 12, y, 8, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x - 15, y);
            ctx.quadraticCurveTo(x - 25, y - 5, x - 30, y - 15);
            ctx.stroke();
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(x - 30, y - 15, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTrap(x, y, extended) {
            const height = extended ? 40 : 10;
            ctx.fillStyle = '#654321';
            ctx.fillRect(x - 30, y, 60, 10);
            ctx.fillStyle = '#B87333';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 25 + i * 12, y);
                ctx.lineTo(x - 20 + i * 12, y - height);
                ctx.lineTo(x - 15 + i * 12, y);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawMummy(x, y) {
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(x - 15, y - 40, 30, 50);
            ctx.fillRect(x - 12, y - 55, 24, 25);
            ctx.fillRect(x - 30, y - 30, 15, 10);
            ctx.fillRect(x + 15, y - 30, 15, 10);
            ctx.fillRect(x - 12, y + 10, 10, 20);
            ctx.fillRect(x + 2, y + 10, 10, 20);
            ctx.strokeStyle = '#D3D3D3';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 15, y - 35 + i * 10);
                ctx.lineTo(x + 15, y - 35 + i * 10);
                ctx.stroke();
            }
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.arc(x - 5, y - 48, 4, 0, Math.PI * 2);
            ctx.arc(x + 5, y - 48, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTreasureChest(x, y, locked) {
            const w = 60, h = 40;
            ctx.fillStyle = '#654321';
            ctx.fillRect(x - w/2, y - h/2, w, h);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - w/2 + 5, y - h/2 + 5, w - 10, h - 10);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.strokeRect(x - w/2, y - h/2, w, h);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 8, y - 5, 16, 12);
            if (locked) {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(x - 20 + i * 10, y - h/2 - 10 - Math.sin(gameTime/10 + i) * 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ============ EXPLORADORES ============
        function drawExplorer(x, y, type) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(PLAYER_SCALE, PLAYER_SCALE);
            ctx.translate(-x, -y);

            switch(type) {
                case 'classic': drawClassicExplorer(x, y); break;
                case 'indiana': drawIndianaExplorer(x, y); break;
                case 'archaeologist': drawArchaeologistExplorer(x, y); break;
                case 'adventurer': drawAdventurerExplorer(x, y); break;
                case 'pharaoh': drawPharaohExplorer(x, y); break;
                case 'cleopatra': drawCleopatraExplorer(x, y); break;
                case 'anubis': drawAnubisExplorer(x, y); break;
            }
            ctx.restore();
        }

        function drawClassicExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#FFDBAC');
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 4, y - 23, 2, 2);
            ctx.fillRect(x + 2, y - 23, 2, 2);
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(x - 15, y - 30, 30, 5);
            ctx.fillRect(x - 10, y - 35, 20, 8);
            drawRect(x - 7, y - 8, 14, 18, '#9B8B54');
            drawRect(x - 13, y - 5, 6, 12, '#9B8B54');
            drawRect(x + 7, y - 5, 6, 12, '#9B8B54');
            drawRect(x - 7, y + 10, 6, 15, '#654321');
            drawRect(x + 1, y + 10, 6, 15, '#654321');
        }

        function drawIndianaExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#FFDBAC');
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 4, y - 23, 2, 2);
            ctx.fillRect(x + 2, y - 23, 2, 2);
            ctx.fillStyle = '#654321';
            ctx.fillRect(x - 18, y - 30, 36, 4);
            ctx.fillRect(x - 12, y - 38, 24, 10);
            drawRect(x - 7, y - 8, 14, 18, '#8B4513');
            drawRect(x - 13, y - 5, 6, 12, '#8B4513');
            drawRect(x + 7, y - 5, 6, 12, '#8B4513');
            drawRect(x - 7, y + 10, 6, 15, '#654321');
            drawRect(x + 1, y + 10, 6, 15, '#654321');
        }

        function drawArchaeologistExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#FFDBAC');
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 12, y - 28, 24, 15);
            drawRect(x - 7, y - 8, 14, 18, '#D2B48C');
            drawRect(x - 13, y - 5, 6, 12, '#FFF');
            drawRect(x + 7, y - 5, 6, 12, '#FFF');
            drawRect(x - 7, y + 10, 6, 15, '#4682B4');
            drawRect(x + 1, y + 10, 6, 15, '#4682B4');
        }

        function drawAdventurerExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#FFDBAC');
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(x - 12, y - 30, 24, 5);
            drawRect(x - 7, y - 8, 14, 18, '#556B2F');
            drawRect(x - 13, y - 5, 6, 12, '#556B2F');
            drawRect(x + 7, y - 5, 6, 12, '#556B2F');
            drawRect(x - 7, y + 10, 6, 15, '#8B7355');
            drawRect(x + 1, y + 10, 6, 15, '#8B7355');
        }

        function drawPharaohExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#D2691E');
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x - 15, y - 32, 30, 15);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 15, y - 32, 30, 3);
            ctx.fillRect(x - 15, y - 25, 30, 2);
            drawRect(x - 7, y - 8, 14, 18, '#FFF');
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 10, y - 8, 20, 3);
            drawRect(x - 13, y - 5, 6, 12, '#FFF');
            drawRect(x + 7, y - 5, 6, 12, '#FFF');
            drawRect(x - 7, y + 10, 6, 15, '#4169E1');
            drawRect(x + 1, y + 10, 6, 15, '#4169E1');
        }

        function drawCleopatraExplorer(x, y) {
            drawCircle(x, y - 20, 12, '#D2691E');
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 12, y - 30, 24, 15);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 12, y - 30, 24, 3);
            drawRect(x - 7, y - 8, 14, 18, '#FFF');
            drawRect(x - 13, y - 5, 6, 12, '#FFF');
            drawRect(x + 7, y - 5, 6, 12, '#FFF');
            drawRect(x - 7, y + 10, 6, 15, '#9370DB');
            drawRect(x + 1, y + 10, 6, 15, '#9370DB');
        }

        function drawAnubisExplorer(x, y) {
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 10, y - 30, 20, 20);
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 30);
            ctx.lineTo(x - 15, y - 40);
            ctx.lineTo(x - 5, y - 30);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10, y - 30);
            ctx.lineTo(x + 15, y - 40);
            ctx.lineTo(x + 5, y - 30);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 4, y - 24, 3, 0, Math.PI * 2);
            ctx.arc(x + 4, y - 24, 3, 0, Math.PI * 2);
            ctx.fill();
            drawRect(x - 7, y - 8, 14, 18, '#000');
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 2, y - 5, 4, 15);
            drawRect(x - 13, y - 5, 6, 12, '#000');
            drawRect(x + 7, y - 5, 6, 12, '#000');
            drawRect(x - 7, y + 10, 6, 15, '#2F4F4F');
            drawRect(x + 1, y + 10, 6, 15, '#2F4F4F');
        }

        function drawPlayer() {
            const x = player.x - cameraX;
            const y = player.y;
            if (player.invincible && Math.floor(Date.now() / 100) % 2 === 0) return;
            drawExplorer(x, y, gameData.currentExplorer);
        }

        // ============ KEYPAD MEJORADO ============
        let keypadButtons = [];

        function drawKeypad() {
            // Overlay oscuro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, 1000, 700);

            keypadButtons = [];
            const div = currentTemple.division;
            const needsRemainder = gameData.currentLevel >= 7;

            // Panel principal con estilo egipcio
            const panelX = 200, panelY = 80, panelW = 600, panelH = 540;
            
            // Fondo del panel con gradiente dorado
            const gradient = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.3, '#D2691E');
            gradient.addColorStop(0.7, '#CD853F');
            gradient.addColorStop(1, '#8B4513');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(panelX, panelY, panelW, panelH, 20);
            ctx.fill();

            // Borde dorado
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.stroke();

            // Decoraci√≥n egipcia superior
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(panelX + 50, panelY + 10, panelW - 100, 4);
            ctx.fillRect(panelX + 80, panelY + 18, panelW - 160, 2);

            // T√≠tulo
            drawText('üè∫ DIVISI√ìN üè∫', 500, panelY + 55, 32, '#FFD700', 'center', true);

            // Divisi√≥n a resolver
            drawText(`${div[0]} √∑ ${div[1]} = ?`, 500, panelY + 110, 48, '#FFF', 'center', true);

            // Caja de respuesta
            const inputX = 300, inputY = panelY + 140, inputW = 400, inputH = 55;
            drawRect(inputX, inputY, inputW, inputH, '#FFF8DC', '#8B4513', 12);
            drawText(playerAnswer || '...', 500, inputY + inputH/2, 36, playerAnswer ? '#333' : '#999', 'center');

            if (needsRemainder) {
                drawText('(cociente + resto, ej: 6r1 = 61)', 500, inputY + inputH + 20, 16, '#FFE4B5', 'center');
            }

            // Teclado num√©rico
            const numStartY = inputY + inputH + (needsRemainder ? 45 : 25);
            const btnSize = 65;
            const gap = 12;
            const numStartX = 500 - (5 * btnSize + 4 * gap) / 2;

            // Fila 1: 1-5
            for (let i = 1; i <= 5; i++) {
                const bx = numStartX + (i - 1) * (btnSize + gap);
                const by = numStartY;
                drawNumButton(bx, by, btnSize, btnSize, i.toString());
                keypadButtons.push({ x: bx, y: by, w: btnSize, h: btnSize, action: 'number', value: i.toString() });
            }

            // Fila 2: 6-0
            for (let i = 6; i <= 10; i++) {
                const bx = numStartX + (i - 6) * (btnSize + gap);
                const by = numStartY + btnSize + gap;
                const num = i === 10 ? '0' : i.toString();
                drawNumButton(bx, by, btnSize, btnSize, num);
                keypadButtons.push({ x: bx, y: by, w: btnSize, h: btnSize, action: 'number', value: num });
            }

            // Fila 3: Borrar, Aceptar, Cancelar
            const actionY = numStartY + 2 * (btnSize + gap) + 15;
            const actionW = 150;
            const actionH = 55;
            const actionGap = 30;
            const actionStartX = 500 - (3 * actionW + 2 * actionGap) / 2;

            // Bot√≥n Borrar
            drawActionButton(actionStartX, actionY, actionW, actionH, '‚å´ Borrar', '#E67E22');
            keypadButtons.push({ x: actionStartX, y: actionY, w: actionW, h: actionH, action: 'delete' });

            // Bot√≥n Aceptar
            drawActionButton(actionStartX + actionW + actionGap, actionY, actionW, actionH, '‚úì OK', '#27ae60');
            keypadButtons.push({ x: actionStartX + actionW + actionGap, y: actionY, w: actionW, h: actionH, action: 'check' });

            // Bot√≥n Cancelar
            drawActionButton(actionStartX + 2 * (actionW + actionGap), actionY, actionW, actionH, '‚úï Salir', '#c0392b');
            keypadButtons.push({ x: actionStartX + 2 * (actionW + actionGap), y: actionY, w: actionW, h: actionH, action: 'cancel' });

            // Decoraci√≥n inferior
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(panelX + 80, panelY + panelH - 20, panelW - 160, 2);
            ctx.fillRect(panelX + 50, panelY + panelH - 12, panelW - 100, 4);
        }

        function drawNumButton(x, y, w, h, text) {
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.roundRect(x + 3, y + 3, w, h, 12);
            ctx.fill();

            // Bot√≥n
            const gradient = ctx.createLinearGradient(x, y, x, y + h);
            gradient.addColorStop(0, '#F5DEB3');
            gradient.addColorStop(1, '#DEB887');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 12);
            ctx.fill();

            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.stroke();

            drawText(text, x + w/2, y + h/2, 32, '#654321', 'center');
        }

        function drawActionButton(x, y, w, h, text, color) {
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.roundRect(x + 3, y + 3, w, h, 12);
            ctx.fill();

            // Bot√≥n
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 12);
            ctx.fill();

            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            drawText(text, x + w/2, y + h/2, 20, '#FFF', 'center');
        }

        function handleKeypadClick(x, y) {
            for (let btn of keypadButtons) {
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    playSound(400, 500, 0.1);
                    
                    if (btn.action === 'number') {
                        if (playerAnswer.length < 5) {
                            playerAnswer += btn.value;
                        }
                    } else if (btn.action === 'delete') {
                        playerAnswer = playerAnswer.slice(0, -1);
                    } else if (btn.action === 'check') {
                        submitAnswer();
                    } else if (btn.action === 'cancel') {
                        playerAnswer = '';
                        showingKeypad = false;
                    }
                    return;
                }
            }
        }

        function submitAnswer() {
            if (!playerAnswer) return;

            const div = currentTemple.division;
            const correctAnswer = Math.floor(div[0] / div[1]);
            const remainder = div[0] % div[1];
            const needsRemainder = gameData.currentLevel >= 7;

            let isCorrect = false;
            if (needsRemainder && remainder > 0) {
                const expectedAnswer = correctAnswer.toString() + remainder.toString();
                isCorrect = playerAnswer === expectedAnswer;
            } else {
                isCorrect = parseInt(playerAnswer) === correctAnswer;
            }

            if (isCorrect) {
                playSound(523, 784, 0.3);
                gameData.coins += 2;
                gameData.divisionsCorrect++;
                currentTemple.solved = true;
            } else {
                playSound(200, 150, 0.3);
                gameData.coins = Math.max(0, gameData.coins - 1);
            }

            playerAnswer = '';
            showingKeypad = false;
        }

        // ============ ESCENAS ============
        function drawMenu() {
            const gradient = ctx.createLinearGradient(0, 0, 0, 700);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.6, '#F4A460');
            gradient.addColorStop(1, '#DEB887');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1000, 700);

            // Sol
            drawCircle(850, 100, 60, '#FFD700');

            // Pir√°mides de fondo
            ctx.fillStyle = '#C9A876';
            ctx.beginPath();
            ctx.moveTo(150, 350);
            ctx.lineTo(250, 150);
            ctx.lineTo(350, 350);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(600, 350);
            ctx.lineTo(720, 120);
            ctx.lineTo(840, 350);
            ctx.closePath();
            ctx.fill();

            drawText('üè∫ DIVISI√ìN QUEST', 500, 80, 52, '#8B4513', 'center', true);
            drawText('Aventura Egipcia', 500, 140, 38, '#D2691E', 'center', true);
            drawText(`üí∞ ${gameData.coins}  ‚ù§Ô∏è ${gameData.lives}`, 500, 210, 32, '#FFD700', 'center');

            const buttons = [];
            for (let i = 1; i <= 9; i++) {
                const row = Math.floor((i - 1) / 3);
                const col = (i - 1) % 3;
                const x = 300 + col * 150;
                const y = 290 + row * 90;
                const isUnlocked = i <= gameData.unlockedLevels;

                const btn = drawButton(x, y, 110, 65, `Nivel ${i}`, isUnlocked ? '#E67E22' : '#7F8C8D');
                if (isUnlocked) buttons.push({ ...btn, action: 'level', level: i });
            }

            const shopBtn = drawButton(350, 620, 300, 55, 'üè∫ TIENDA', '#D35400');
            buttons.push({ ...shopBtn, action: 'shop' });

            return buttons;
        }

        function initGame() {
            gameData.divisionsCorrect = 0;
            player.x = 100;
            player.y = 500;
            player.velocityX = 0;
            player.velocityY = 0;
            player.invincible = false;
            player.invincibleTimer = 0;
            cameraX = 0;
            showingKeypad = false;
            playerAnswer = '';
            gameTime = 0;

            currentDivisions = levelDivisions[gameData.currentLevel];
            temples = [];
            scorpions = [];
            traps = [];

            const positions = [
                [400, 580], [700, 450], [1000, 580], [1300, 400],
                [1600, 580], [1900, 480], [2200, 580], [2500, 420],
                [2800, 580], [3100, 460]
            ];

            for (let i = 0; i < 10; i++) {
                temples.push({
                    x: positions[i][0],
                    y: positions[i][1],
                    division: currentDivisions[i],
                    solved: false
                });
            }

            scorpions.push({ x: 800, y: 625, velocityX: 2, direction: 1, active: true });
            scorpions.push({ x: 2000, y: 625, velocityX: 1.5, direction: -1, active: true });

            traps.push({ x: 1100, y: 650, timer: 0, extended: false });
            traps.push({ x: 1700, y: 650, timer: 60, extended: false });
            traps.push({ x: 2400, y: 650, timer: 120, extended: false });

            mummy = { x: 3500, y: 580, velocityX: 3, direction: -1, active: true };
            treasureChest = {
                x: 3700, y: 470, locked: true,
                division: chestDivisions[gameData.currentLevel]
            };
        }

        function drawGame() {
            // Fondo
            const gradient = ctx.createLinearGradient(0, 0, 0, 700);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.6, '#F4A460');
            gradient.addColorStop(1, '#DEB887');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1000, 700);

            // Suelo
            ctx.fillStyle = '#EDC9AF';
            ctx.fillRect(0 - cameraX, 650, 4000, 50);

            // Plataformas
            ctx.fillStyle = '#C9A876';
            const platforms = [
                [300, 520], [600, 470], [900, 520], [1200, 440],
                [1500, 520], [1800, 500], [2100, 520], [2400, 460],
                [2700, 520], [3000, 480], [3300, 450]
            ];
            platforms.forEach(([x, y]) => {
                ctx.fillRect(x - cameraX, y, 150, 20);
            });

            // Elementos del juego
            temples.forEach(temple => {
                const tx = temple.x - cameraX;
                if (tx > -200 && tx < 1200) drawPyramid(tx, temple.y, temple.solved);
            });

            traps.forEach(trap => {
                const tx = trap.x - cameraX;
                if (tx > -100 && tx < 1100) drawTrap(tx, trap.y, trap.extended);
            });

            scorpions.forEach(s => {
                if (s.active) {
                    const sx = s.x - cameraX;
                    if (sx > -100 && sx < 1100) drawScorpion(sx, s.y);
                }
            });

            if (gameData.divisionsCorrect >= 10) {
                const mx = mummy.x - cameraX;
                const cx = treasureChest.x - cameraX;
                if (mx > -200 && mx < 1200) drawMummy(mx, mummy.y);
                if (cx > -100 && cx < 1100) drawTreasureChest(cx, treasureChest.y, treasureChest.locked);
            }

            drawPlayer();

            // UI superior
            drawRect(0, 0, 1000, 70, 'rgba(139, 69, 19, 0.9)');
            drawText(`üí∞ ${gameData.coins}`, 25, 35, 26, '#FFD700');
            let heartsText = '';
            for (let i = 0; i < gameData.lives; i++) heartsText += '‚ù§Ô∏è';
            drawText(heartsText, 250, 35, 26, '#FF0000');
            drawText(`üè∫ ${gameData.divisionsCorrect}/10`, 500, 35, 26, '#FFF', 'center');
            drawText(`Nivel ${gameData.currentLevel}`, 950, 35, 26, '#FFF', 'right');

            // Controles t√°ctiles
            const buttons = [];
            const controlY = 620;
            const controlRadius = 45;

            // Izquierda
            ctx.fillStyle = touchLeft ? 'rgba(255, 200, 100, 0.9)' : 'rgba(139, 69, 19, 0.8)';
            ctx.beginPath();
            ctx.arc(100, controlY, controlRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.stroke();
            drawText('‚óÄ', 100, controlY, 36, '#FFF', 'center');

            // Saltar
            ctx.fillStyle = touchJump ? 'rgba(255, 220, 100, 0.9)' : 'rgba(212, 175, 55, 0.85)';
            ctx.beginPath();
            ctx.arc(220, controlY, controlRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 4;
            ctx.stroke();
            drawText('‚ñ≤', 220, controlY, 36, '#FFF', 'center');

            // Derecha
            ctx.fillStyle = touchRight ? 'rgba(255, 200, 100, 0.9)' : 'rgba(139, 69, 19, 0.8)';
            ctx.beginPath();
            ctx.arc(340, controlY, controlRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.stroke();
            drawText('‚ñ∂', 340, controlY, 36, '#FFF', 'center');

            controlZones.left = { cx: 100, cy: controlY, r: controlRadius + 15 };
            controlZones.jump = { cx: 220, cy: controlY, r: controlRadius + 15 };
            controlZones.right = { cx: 340, cy: controlY, r: controlRadius + 15 };

            return buttons;
        }

        function updateGame() {
            gameTime++;

            // Movimiento
            if (keys['ArrowLeft'] || keys['a'] || touchLeft) {
                player.velocityX = -player.speed;
            } else if (keys['ArrowRight'] || keys['d'] || touchRight) {
                player.velocityX = player.speed;
            } else {
                player.velocityX = 0;
            }

            // Salto
            if ((keys['ArrowUp'] || keys['w'] || keys[' '] || touchJump) && player.onGround) {
                player.velocityY = -player.jumpPower;
                player.onGround = false;
            }

            // F√≠sica
            player.velocityY += player.gravity;
            player.x += player.velocityX;
            player.y += player.velocityY;

            // L√≠mites
            if (player.x < 30) player.x = 30;
            if (player.x > 3850) player.x = 3850;

            // Suelo
            if (player.y > 610) {
                player.y = 610;
                player.velocityY = 0;
                player.onGround = true;
            }

            // Plataformas
            const platforms = [
                [300, 520], [600, 470], [900, 520], [1200, 440],
                [1500, 520], [1800, 500], [2100, 520], [2400, 460],
                [2700, 520], [3000, 480], [3300, 450]
            ];
            platforms.forEach(([px, py]) => {
                if (player.x > px - 20 && player.x < px + 170 &&
                    player.y > py - 40 && player.y < py + 10 &&
                    player.velocityY > 0) {
                    player.y = py - 35;
                    player.velocityY = 0;
                    player.onGround = true;
                }
            });

            // C√°mara
            const targetCameraX = player.x - 400;
            cameraX += (targetCameraX - cameraX) * 0.1;
            if (cameraX < 0) cameraX = 0;
            if (cameraX > 2900) cameraX = 2900;

            // Trampas
            traps.forEach(trap => {
                trap.timer++;
                if (trap.timer > 120) {
                    trap.extended = !trap.extended;
                    trap.timer = 0;
                }
                if (trap.extended && !player.invincible) {
                    if (Math.abs(player.x - trap.x) < 40 && player.y > 580) {
                        gameData.coins = Math.max(0, gameData.coins - 2);
                        player.invincible = true;
                        player.invincibleTimer = 90;
                        player.velocityY = -10;
                    }
                }
            });

            // Escorpiones
            scorpions.forEach(s => {
                if (s.active) {
                    s.x += s.velocityX * s.direction;
                    if (s.x < 600 || s.x > 2200) s.direction *= -1;

                    if (!player.invincible) {
                        const dx = Math.abs(player.x - s.x);
                        const dy = Math.abs(player.y - s.y);
                        if (dx < 40 && dy < 50) {
                            if (player.velocityY > 0 && player.y < s.y - 20) {
                                s.active = false;
                                gameData.coins += 1;
                                player.velocityY = -10;
                                playSound(523, 784, 0.2);
                            } else {
                                gameData.coins = Math.max(0, gameData.coins - 3);
                                player.invincible = true;
                                player.invincibleTimer = 120;
                                player.x -= 80 * s.direction;
                            }
                        }
                    }
                }
            });

            // Momia
            if (gameData.divisionsCorrect >= 10 && mummy.active) {
                mummy.x += mummy.velocityX * mummy.direction;
                if (mummy.x < 3250 || mummy.x > 3750) mummy.direction *= -1;

                if (!player.invincible) {
                    const dx = Math.abs(player.x - mummy.x);
                    const dy = Math.abs(player.y - mummy.y);
                    if (dx < 50 && dy < 60) {
                        gameData.coins = 0;
                        player.invincible = true;
                        player.invincibleTimer = 120;
                        player.x -= 100;
                    }
                }
            }

            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) player.invincible = false;
            }

            // Colisi√≥n con pir√°mides
            if (!showingKeypad) {
                temples.forEach(temple => {
                    if (!temple.solved && Math.abs(player.x - temple.x) < 80 && Math.abs(player.y - temple.y) < 80) {
                        showingKeypad = true;
                        currentTemple = temple;
                        playerAnswer = '';
                    }
                });
            }

            // Colisi√≥n con cofre
            if (gameData.divisionsCorrect >= 10 && treasureChest.locked) {
                if (Math.abs(player.x - treasureChest.x) < 60 && Math.abs(player.y - treasureChest.y) < 50) {
                    if (!showingKeypad) {
                        showingKeypad = true;
                        currentTemple = { division: treasureChest.division, solved: false };
                        playerAnswer = '';
                    }
                }
            }

            // Victoria
            if (gameData.divisionsCorrect >= 10 && !treasureChest.locked && player.x > 3800) {
                gameData.scene = 'victory';
            }
        }

        function drawVictory() {
            const gradient = ctx.createLinearGradient(0, 0, 0, 700);
            gradient.addColorStop(0, '#FFD700');
            gradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1000, 700);

            drawText('üèÜ ¬°NIVEL COMPLETADO! üèÜ', 500, 150, 48, '#8B4513', 'center', true);
            drawText(`üí∞ Monedas: ${gameData.coins}`, 500, 270, 32, '#654321', 'center');
            drawText(`‚ù§Ô∏è Vidas: ${gameData.lives}`, 500, 320, 32, '#DC143C', 'center');

            if (gameData.currentLevel === gameData.unlockedLevels && gameData.currentLevel < 9) {
                gameData.unlockedLevels++;
                drawText(`üîì Nivel ${gameData.unlockedLevels} desbloqueado`, 500, 380, 24, '#27ae60', 'center');
            }

            const buttons = [];
            const shopBtn = drawButton(325, 450, 350, 60, 'üè∫ TIENDA', '#D35400');
            buttons.push({ ...shopBtn, action: 'shop' });

            const menuBtn = drawButton(325, 530, 350, 60, 'üè† MEN√ö', '#E67E22');
            buttons.push({ ...menuBtn, action: 'menu' });

            return buttons;
        }

        function drawGameOver() {
            drawRect(0, 0, 1000, 700, '#2C3E50');
            drawText('üíÄ GAME OVER üíÄ', 500, 200, 54, '#e74c3c', 'center', true);
            drawText('¬°Te quedaste sin vidas!', 500, 280, 28, '#ECF0F1', 'center');
            drawText(`üí∞ ${gameData.coins}`, 500, 340, 24, '#FFD700', 'center');

            const buttons = [];
            const retryBtn = drawButton(325, 420, 350, 60, 'üîÑ REINTENTAR', '#E67E22');
            buttons.push({ ...retryBtn, action: 'retry' });

            const menuBtn = drawButton(325, 500, 350, 60, 'üè† MEN√ö', '#95A5A6');
            buttons.push({ ...menuBtn, action: 'menu' });

            return buttons;
        }

        function drawShop() {
            const gradient = ctx.createLinearGradient(0, 0, 0, 700);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(1, '#D2691E');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1000, 700);

            drawText('üè∫ TIENDA', 500, 50, 40, '#FFD700', 'center', true);
            drawText(`üí∞ ${gameData.coins}`, 500, 100, 28, '#FFD700', 'center');

            const buttons = [];

            explorers.forEach((explorer, index) => {
                const row = Math.floor(index / 4);
                const col = index % 4;
                const x = 80 + col * 230;
                const y = 150 + row * 200;

                drawRect(x, y, 200, 170, 'rgba(0,0,0,0.3)', '#FFD700', 15);

                // Explorador miniatura
                ctx.save();
                const mx = x + 100, my = y + 70;
                ctx.translate(mx, my);
                ctx.scale(1.2, 1.2);
                ctx.translate(-mx, -my);
                switch(explorer.id) {
                    case 'classic': drawClassicExplorer(mx, my); break;
                    case 'indiana': drawIndianaExplorer(mx, my); break;
                    case 'archaeologist': drawArchaeologistExplorer(mx, my); break;
                    case 'adventurer': drawAdventurerExplorer(mx, my); break;
                    case 'pharaoh': drawPharaohExplorer(mx, my); break;
                    case 'cleopatra': drawCleopatraExplorer(mx, my); break;
                    case 'anubis': drawAnubisExplorer(mx, my); break;
                }
                ctx.restore();

                drawText(explorer.name, x + 100, y + 120, 16, '#FFF', 'center');

                const owned = gameData.ownedExplorers.includes(explorer.id);
                const equipped = gameData.currentExplorer === explorer.id;
                const canAfford = gameData.coins >= explorer.price;

                if (equipped) {
                    drawButton(x + 25, y + 135, 150, 28, '‚úì Equipado', '#27ae60', 14);
                } else if (owned) {
                    const btn = drawButton(x + 25, y + 135, 150, 28, 'Equipar', '#3498db', 14);
                    buttons.push({ ...btn, action: 'equip', explorer: explorer.id });
                } else if (explorer.price === 0) {
                    const btn = drawButton(x + 25, y + 135, 150, 28, 'Gratis', '#27ae60', 14);
                    buttons.push({ ...btn, action: 'buy', explorer: explorer.id, price: 0 });
                } else {
                    const btn = drawButton(x + 25, y + 135, 150, 28, `üí∞ ${explorer.price}`, canAfford ? '#E67E22' : '#7F8C8D', 14);
                    if (canAfford) buttons.push({ ...btn, action: 'buy', explorer: explorer.id, price: explorer.price });
                }
            });

            const backBtn = drawButton(400, 620, 200, 50, '‚Üê Volver', '#95A5A6');
            buttons.push({ ...backBtn, action: 'menu' });

            return buttons;
        }

        function handleClick(x, y) {
            let buttons = [];

            if (gameData.scene === 'menu') buttons = drawMenu();
            else if (gameData.scene === 'victory') buttons = drawVictory();
            else if (gameData.scene === 'shop') buttons = drawShop();
            else if (gameData.scene === 'gameover') buttons = drawGameOver();

            buttons.forEach(btn => {
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    handleAction(btn);
                }
            });
        }

        function handleAction(btn) {
            playSound(300, 400, 0.1);
            
            switch(btn.action) {
                case 'level':
                    gameData.currentLevel = btn.level;
                    gameData.scene = 'game';
                    initGame();
                    break;
                case 'shop':
                    gameData.scene = 'shop';
                    break;
                case 'menu':
                    gameData.scene = 'menu';
                    gameData.lives = 3;
                    break;
                case 'retry':
                    gameData.lives = 3;
                    gameData.scene = 'game';
                    initGame();
                    break;
                case 'buy':
                    gameData.coins -= btn.price;
                    gameData.ownedExplorers.push(btn.explorer);
                    gameData.currentExplorer = btn.explorer;
                    break;
                case 'equip':
                    gameData.currentExplorer = btn.explorer;
                    break;
            }
        }

        // ============ GAME LOOP ============
        function gameLoop() {
            ctx.clearRect(0, 0, 1000, 700);

            if (gameData.scene === 'menu') {
                drawMenu();
            } else if (gameData.scene === 'game') {
                if (!showingKeypad) updateGame();
                drawGame();
                if (showingKeypad) drawKeypad();
            } else if (gameData.scene === 'victory') {
                drawVictory();
            } else if (gameData.scene === 'shop') {
                drawShop();
            } else if (gameData.scene === 'gameover') {
                drawGameOver();
            }

            requestAnimationFrame(gameLoop);
        }

        gameLoop();

        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw_division.js').catch(() => {});
        }
    </script>
</body>
</html>
